---
title: "Get Started"
format:
  html:
    code-link: true
---

```{r, include = FALSE}
#| eval: false
library(tidyverse)
library(fpaR)

```



# Getting started with time intelligence functions

"time intelligence" is generic name for a collection of functions that perform time related analysis such as calculating either an aggregation of a variable or  period over period comparison.

While conceptually this is straight forward, in practice you will either have missing data, period imbalances, non-standard calendar types or confusing terminology that will generate errors or administrative work to correct.


This package is a collection of functions providing a consistent way to tackle most of your routine and complex functions.

To avoid confusion, each function prints a complete set of instructions of what actions were

## dataset

For our examples we will use the excellent {contoso} dataset.

The {fpaR} comes with a tibble version of the dataset for practice but recommend you install the {contoso} package as it comes with both tibble and a [duckdb](https://duckdb.org/) database version so you can practice using function against either source of data.

While the {contoso} dataset has many tables, we will focus on the sales (fpaR::sales) table for our examples.

Here we see a typical transaction table with dimensions such as customer_key, product_key, store_key and for each transaction there are a few metrics, for example unit_price, quantity, cogs and margin. 

When doing time intelligence functions, you can simplify your framework to four elements:

- Date column
- Grouping columns
- Aggregation column
- Calendar type

When you look at the dataset you will see that some groups only have tranasaction on certain days while others have trasnactions in all the periods.

Lets talk through some common "time intelligence" functions and the challenges we would normally meet on the way and how we will solve them. 

1) Incomplete calendar
2) Imbalanced periods
3) Lack of consistency
4) Inconsistent data interface 
5) Non-standard calendar types

# the basics

What is our workflow?

- your data (tibble or dbi form)
- identify the (optional) groups you want via [dplyr::group_by()](https://dplyr.tidyverse.org/reference/group_by.html)
- Select and execute the time intelligence function 
- Execute the function with fpaR::calculate() 
- Optional: keep as dbi or return as tibble with dplyr::collect()

Let's see in action by calling the fpar::ytd() function to calculate the year-to-date margin by order date for all transactions

```{r}
#| eval: false
library(tidyverse)
library(fpaR)


sales |> #<1>
  ytd(order_date,.value=margin,calendar_type="standard") #<2>


```
1. dataframe
2. year-to-date

When you first execute a ti function, a message is printed to clarify the actions and steps it will take:

- function name & description
- what calendar type is used and any modifications made to calendar to fill in incomplete dates or missing groups
- details of what aggregations actions are used

This will actually return a ti object which is an S7 object. To execute the function, pass the object to fpaR::calculate() and this will then execute the steps and return a duckdb tibble.

You can further return it to a tibble with dplyr::collect()

::: {.callout-note}
## options()

- You can set options(fpar.calculute=TRUE) to avoid the print stage and automatically calculate the object
- You can also set options(fpa.collect=TRUE) to also always return a tibble -- be aware of the size of your data

:::




```{r}
#| eval: false
sales |> #<1>
  ytd(order_date,.value=margin,calendar_type="standard")|> #<2>
  calculate() |>  #<3)
  dplyr::collect()

```

1. dataframe
2. year-to-date
3. execute function and return a duckdb object

What if we want we want to find the year-to-date margin of each store? Simply pass through a grouped tibble with dplyr::group_by() and the ti functions will calculate year-to-date sales for each member of the group.


::: {.callout-note}
## Missing date indicator

A ti object will add a missing date column to indicate where the dataset is missing a date for your awareness

:::

```{r}
#| eval: false
sales |> #<1>
  dplyr::group_by(currency_code) |> #<2>
  ytd(order_date,.value=margin,calendar_type="standard") #<3>

```
1. tibble
2. Add in the groups you want
3. select the ti function


You will see in the print message under the calendar section that a calendar was created with 1 group.


## Understanding the print message

### function name & description

- This will print out the function name and generalized description of what the function is doing
- People tend to use to terms inter-changable when doing time related functions, so this sections provides clarity to what the formula is doing

### calendar
- this clarifies what calendar type is used (standard, 5-5-4, or 4-4-5)
- how dates were missing and replaced
- the number of groups created 
- the names of new columns that were added to the data

## actions
- summary of what the function is doing (eg shifting a period, comparing period balances, etc)

## next steps
- depending on the object, this will list possible functions you can run
```{r}
#| eval: false
sales |> #<1>
  group_by(currency_code) |> 
  mom(.date=order_date,.value=quantity,calendar_type = "standard",lag_n=4) |> #<2>
  complete_calendar() #<3>
```
1. pass data
2. calculute month-over-month for quantity
3. pull a complete calendar with augmented features



