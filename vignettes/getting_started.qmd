---
title: "Getting Standard"
format: html
vignette: >
  %\VignetteIndexEntry{Getting Standard}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---
## How to use fpaR?

### Time Intelligence

When you execute a time intelligence function, it will return a "ti"
class object with a custom print method that explains what the function
is doing and a summary of transformation steps and the calendar
attributes.

```{r}
#| echo: false
#| eval: true
#| label: setup

devtools::load_all()


```


```{r}
#| echo: true
#| eval: true
#| label: print-example-not-run

library(contoso)

contoso::sales |> 
   mtd(.date=order_date,.value = margin,calendar_type = "standard") 

```

This prints a summary of the function's actions,details the calendar's attributes, summarizes the main transformation steps and lists out possible next actions.

To return a tibble of results, pass the ti object through to
`calculate()`.

```{r}
#| echo: true
#| eval: true
#| warning: false
#| error: false
#| message: false
#| code-line-numbers: true
#| label: calculate-example

contoso::sales |>                                                                
   mtd(.date=order_date,.value = margin,calendar_type = "standard") |>  
   calculate()                                                          
```

If you using a tibble, under the hood, `fpaR` is converting your data to
a [duckdb](https://github.com/duckdb/duckdb-r) database.

If your data is in a database, the package will leverage
[dbplyr](https://dbplyr.tidyverse.org/) to execute all the calculations.

Either case use `dplyr::collect()` to return your results to a local
tibble.


```{r}
#| echo: true
#| eval: true
#| warning: false
#| error: false
#| label: collect-example

contoso::sales |>                                                                
   mtd(.date=order_date,.value = margin,calendar_type = "standard") |>  
   calculate() |>                                                       
   dplyr::collect() |>                                               
   head(10)
```

### What if you need the analysis at the group level?

Simply pass through the groups that you want with `dplyr::group_by()`
and time intelligence function will create a custom calendar for each
group level.

This will calculate a complete calendar ensuring each group has a complete calendar with no missing dates.

```{r}
#| echo: true
#| eval: true
#| label: group_by-example
#| code-line-numbers: true

contoso::sales |>   
   dplyr::group_by(customer_key,store_key) |>  
   yoy(.date=order_date,.value = margin,calendar_type = "standard") 


```
The functions will work with your database even if you don't have write permission by creatively leveraging CTEs to create interim tables.

## Why do we need this package when we have lubridate?

[Lubridate](https://lubridate.tidyverse.org/) is an excellent package
and is heavily used by the package. The issue isn't lubridate but rather
issues you may not be aware of in your package.

Time-based comparisons, such as Year-over-Year (YoY),
Quarter-over-Quarter (QoQ), and Month-to-Date (MTD), are common for
tracking business performance. However, they come with challenges:

-   Many datasets **do not have continuous dates**, especially if data
    is recorded only on business days or for active transactions

-   Period imbalances between periods (Eg. the different number of days
    between February vs. January) can create misleading analysis or
    trends

-   Your analysis may need to reference a non-standard calendar such as
    a 5-5-4, 4-4-5, or 13 month calendar

-   Your data may be in excel sheets, csv or databases and you need to
    inter-operable framework to switch between all your data types

### Issue 1: Continuous Dates

Referencing the table below, if we use `dplyr::lag()` to compare **Day-over-Day (DoD)** revenue, we
would be missing `2024-01-02`, `2024-01-04`, and `2024-01-05` which will
lead to incorrect answers or trends.

```{r}
#| echo: false
#| warning: false
#| message: false
#| error: false
#| label: missing-date-example

tibble::tibble(
  order_date=c(" 2024-01-01","2024-01-03","2024-01-06","2024-01-07","2024-01-08","2024-01-09","2024-01-11")
  ,margin=c(1200,1100,1300,900,1200,850,1450)
) |> 
  tinytable::tt()
```


To correct this, `fpaR` will automatically complete your calendar for each group for
the missing periods to ensure there are no missing periods when
calculating trends.

## Issue 2

```{r}
#| echo: false
#| eval: false
#| warning: false
#| message: false
#| error: false
#| label: issue2-example

contoso::sales |> 
   pmtd(order_date,margin,"standard",1) |> 
   calculate() |> 
    filter(
      TRUE
      ,month(date) %in% c(2)
      ,year(date) %in% c(2022)
   ) |> 
   arrange(desc(date))  |> 
   collect() |> 
   head(10)
   
```


