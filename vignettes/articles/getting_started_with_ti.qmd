---
title: "Getting started"
subtitle: "How to use time-intilligence functions"
format: html
---

```{r}
#| echo: false
#| label: setup
#| include: false
#| eval: true

library(dplyr)
library(fpaR)

hook <- fansi::set_knit_hooks(knitr::knit_hooks, which = c("output", "warning", "error", "message"))

options(crayon.enabled = TRUE)


```


## How to use fpaR?

Simply pass your data in either tibble or a lazy DBI object to the time intelligence function and input the required arguments.

> Regardless if you pass a tibble or lazy DBI object, all time intelligence functions will return a lazy DBI object for performance reasons

We will use `mtd()` function to calculate the month-to-date sum of contoso's company' margin (`contoso::sales`).

Most time intelligence functions follow the same structure:

-  Specify the date column to index the time intelligence functions (eg. `order_date` or `deliver_date`)
-  Specify the value column to aggregate
-  If there is a period rollback / rollforward then clarify the number of periods to roll
-  Clarify if we are using a "standard" calendar or non-standard variation (currently supports 5-4-4, 4-4-5 and 4-5-4 calendars) see [standard vs. non standard calendar article](https://usrbinr.github.io/fpaR/articles/calendar_types.html)

> For most of your uses cases, you are likely to reference "standard" calendar which is your standard gregorian calendar:
> - 365 days in a year except for leap years where you have 366, 7 days make up a week, January has 30 days, etc

When you execute `mtd()`, your console return a `ti` object and will print a  summary of the function's actions, details the calendar's attributes, describes the main transformation steps and lists out possible next actions.


```{r}
#| label: print-example-run
#| echo: true
#| eval: true

contoso::sales |> 
   fpaR::mtd(.date=order_date,.value = margin,calendar_type = "standard")

```


To return the results to a lazy tibble of results, pass the ti object through to
`calculate()`.

```{r}
#| label: calculate-example
#| eval: false
#| echo: true
#| warning: false
#| error: false
#| message: false

contoso::sales |>                                                          
   fpaR::mtd(.date=order_date,.value = margin,calendar_type = "standard") |>  
   fpaR::calculate()                                                          
```


If you using a tibble, under the hood, `fpaR` is converting your data to a [duckdb](https://github.com/duckdb/duckdb-r) database

If your data is in a database, the package will leverage [dbplyr](https://dbplyr.tidyverse.org/) to execute all the calculations

Either case use `dplyr::collect()` to return your results to a local tibble

```{r}
#| label: collect-example
#| echo: true
#| warning: false
#| error: false

contoso::sales |>                                                                
   fpaR::mtd(.date=order_date,.value = margin,calendar_type = "standard") |>  
   fpaR::calculate() |>                                                       
   dplyr::collect() |>  
   dplyr::arrange(date) |> 
   head(10)
```

### What if you need the analysis at the group level?

Simply pass through the groups that you want with `dplyr::group_by()` and time intelligence function will create a custom calendar for each group level.

This will calculate a complete calendar ensuring each group has a complete calendar with no missing dates.

```{r}
#| label: group_by-example
#| echo: true
#| eval: false

contoso::sales |>   
   dplyr::group_by(customer_key,store_key) |>  
   fpaR::yoy(.date=order_date,.value = margin,calendar_type = "standard") 


```

In the print, we 

### Why do we need this package when we have lubridate?

[Lubridate](https://lubridate.tidyverse.org/) is an excellent package and is heavily used by the package. The issue isn't lubridate but rather challenges and issues in your dataset that aren't readily visible.


-   Many datasets **do not have continuous dates**, especially if data is recorded only on business days or for active transactions


-   Period imbalances between periods (Eg. the different number of days between February vs. January) can create misleading analysis or trends requiring non-standard calendars (eg. 4-4-5)

-   Calculating time intelligence for groups can lead to larger than memory issues even with smaller datasets


### Issue 1: Continuous Dates

Referencing the @tbl-missing-dates-issues-1 below, if we were use `dplyr::lag()` to compare **Day-over-Day (DoD)** margin, we
would be missing `2024-01-02`, `2024-01-04`, and `2024-01-05` which would lead to incorrect answers or trends.

```{r}
#| label: tbl-missing-dates-issues-1
#| tbl-cap: "Incomplete calendar table can lead to wrong conclusions or trends"
#| echo: false

tibble::tibble(
  date=c(" 2024-01-01","2024-01-03","2024-01-06","2024-01-07","2024-01-08","2024-01-09","2024-01-11")
  ,margin=c(1200,1100,1300,900,1200,850,1450)
) |> 
  tinytable::tt(width=.7)
```


To correct this, `fpaR` will automatically complete your calendar for each group for the missing periods to ensure there are no missing periods when calculating trends.

In @tbl-missing-dates-issue-1-fix-no-echo we see a complete calendar set and a new column, "missing_date_indicator" to indicate how many dates were missing.


```{r}
#| label: tbl-missing-dates-issue-1-fix-no-echo
#| tbl-cap: "Original table now complete with missing dates and a missing date indicator"
#| echo: false

tibble::tibble(
  order_date=lubridate::ymd(c("2024-01-01","2024-01-03","2024-01-06","2024-01-07","2024-01-08","2024-01-09","2024-01-11"))
  ,margin=c(1200,1100,1300,900,1200,850,1450)
) |> 
   fpaR::dod(.date = order_date,.value = margin,calendar_type = "standard") |> 
   fpaR:::create_calendar() |> 
   dplyr::arrange(date) |> 
   dplyr::collect() |>
   tinytable::tt(width=.7)

```

## Issue 2: Period imbalances

When comparing two performance periods with a standard calendar, you often will compare a period with unequal number of days or periods.

For example if you want to compare January sales to February you can get misleading conclusions due to the unequal number of weekends and days in those periods.

> In practice you have two choices:
>
 -  compare periods with similar days (eg. the 28th of February compares should only compare up to the 28th of January) and you omit three days of January sales all together 
>
-  compare have an imbalanced comparison (eg. the 28th of February compares to the 31st of January so that no days are lost).

This package does the second option to  ensure we don't loose any of January's sales but to help flag for imbalance, fpaR will add a column to let you know how many periods (eg. days) are in your comparison period to increase transparency to this dynamic.

To create this example, we will use the `pmtd()` function to calculate the prior month to date cumulative margin in the current month.

```{r}
#| label: issue2-example-echo
#| echo: false
#| eval: false

contoso::sales |>
   fpaR::pmtd(order_date,margin,"standard",lag_n = 1)

```

When we pass the ti object through to `calculate()` and filter the results for February 2022, we would see the below @tbl-issue2-example-no-echo.

On 2022-02-28, we see that is comparing 31 days of the previous period to the 28 days in the current period.



```{r}
#| label: tbl-issue2-example-no-echo
#| echo: false


contoso::sales |> 
   fpaR::pmtd(order_date,margin,"standard",1) |> 
   fpaR::calculate() |> 
    dplyr::filter(
      TRUE
      ,month %in% c(2)
      ,day(date) > 25
      ,year %in% c(2022)
   ) |> 
   dplyr::arrange(date)  |> 
   dplyr::collect() |> 
   tinytable::tt(width=1)
```

### Issues 3: larger than memory

If your data isn't already in a database then fpaR will leverage duckdb to convert your data to enable larger than memory calculation. 

This is necessary for time intelligence functions because when you have grouped data, you need to complete calendar for each group combination. For even modest datasets, this can quickly multiple and grow you data to be larger than memory. 

If your data is already in database, then fpaR will use [dbplyr](https://dbplyr.tidyverse.org/) and will convert the functions to SQL to write the queries.

In either scenario, you can use `dplyr::collect()` to execute your SQL query and return a tibble to your local computer. 



