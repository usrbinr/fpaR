---
title: "Getting started"
subtitle: "How to use time-intilligence functions"
author: "Alejandro Hagan"
format: html
---

```{r}
#| label: setup
#| eval: true
#| echo: false
#| include: false

library(fpaR)
library(dplyr)

quarto::write_yaml_metadata_block(
   date=format(Sys.Date())
   )

hook <- fansi::set_knit_hooks(knitr::knit_hooks, which = c("output", "warning", "error", "message"))

options(crayon.enabled = TRUE)

```

## Introduction

Simply pass your data in either a tibble or a lazy DBI object to the time intelligence function and input the required arguments.

We will use `mtd()` function to calculate the month-to-date sum of contoso's company' margin from their sales dataset (`contoso::sales`).

Most time intelligence functions follow the same structure:

-  Specify the date column to index the time intelligence functions (eg. `order_date`, `deliver_date`, etc)
-  Specify the value column to aggregate (eg. `margin`, `net_margin`, `cogs`, `etc`)
-  If there is a period rollback / rollforward then clarify the number of periods to roll
-  Clarify if we are using a "standard" calendar or non-standard variation (currently supports 5-4-4, 4-4-5 and 4-5-4 calendars) see [standard vs. non standard calendar article](https://usrbinr.github.io/fpaR/articles/calendar_types.html) for more information

> For most of your uses cases, you are likely to reference a "standard" calendar which is your standard gregorian calendar:
> 
-  365 days in a year except for leap years where you have 366
-  24 hours in a day, 7 days in a week 
-  Days of the week cycle through Sunday, Monday, Tuesday, etc
-  12 months in a year
-  January has 30 days, Feburary has 28 (unless its a leap year then 29), etc

When you execute `mtd()`, your console will return a `ti` object displaying a custom print message:

-  A summary of the function's actions
-  Details the calendar's attributes used to support the calculation
-  Describes the main transformation steps and columns that are referenced
-  Lists out possible next actions


```{r}
#| label: print-example-run
#| echo: true
#| eval: true

contoso::sales |> 
   fpaR::mtd(.date=order_date,.value = margin,calendar_type = "standard")

```

To return the results to a lazy DBI object, pass the `ti` object through to `calculate()`.

```{r}
#| label: calculate-example
#| eval: false
#| echo: true
#| warning: false
#| error: false
#| message: false

contoso::sales |>                                                          
   fpaR::mtd(.date=order_date,.value = margin,calendar_type = "standard") |>  
   fpaR::calculate()                                                          
```


If you using a tibble, under the hood, fpa is converting your data to a [duckdb](https://github.com/duckdb/duckdb-r) database

If your data is in a database, the package will leverage [dbplyr](https://dbplyr.tidyverse.org/) to execute all the calculations

Either case use `dplyr::collect()` to return your results to a local tibble


```{r}
#| label: collect-example-echo
#| echo: true
#| eval: false
#| warning: false
#| error: false

contoso::sales |>                                                                
   fpaR::mtd(.date=order_date,.value = margin,calendar_type = "standard") |>  
   fpaR::calculate() |>                                                       
   dplyr::collect()

```

```{r}
#| label: collect-example-no-echo
#| echo: false
#| warning: false
#| error: false

contoso::sales |>                                                                
   fpaR::mtd(.date=order_date,.value = margin,calendar_type = "standard") |>  
   fpaR::calculate() |>                                                       
   dplyr::collect() |>  
   dplyr::arrange(date) |> 
   head(10)
```

### What if you need the analysis at the group level?

Simply pass the groups that you want to `dplyr::group_by()` and time intelligence function will create a custom calendar for each group level.

This ensures that each group will have a complete calendar ensuring no group member has any missing dates. 

```{r}
#| label: group_by-example
#| echo: true
#| eval: false

contoso::sales |>   
   dplyr::group_by(customer_key,store_key) |>  
   fpaR::yoy(.date=order_date,.value = margin,calendar_type = "standard") 


```

## Why do we need this package when we have lubridate?

[Lubridate](https://lubridate.tidyverse.org/) is an excellent package and is is at the core of many of fpaR's functions. The issue isn't lubridate but rather the challenges and issues in your dataset that typically don't allow you to directly use lubridate. 

The advantage of this package is that it will perform all the of the required pre-processing steps for you.


-   Issue 1: Many datasets **do not have continuous dates**, especially if data is recorded only on business days or for active transactions


-   Issue 2: Period imbalances between periods (Eg. the different number of days between February vs. January) can create misleading analysis/trends or you analysis requires non-standard calendar types

-   Issue 3: Calculating time intelligence for groups can lead to larger than memory issues even with smaller datasets


### Issue 1: Continuous Dates

Referencing the @tbl-missing-dates-issues-1 below, if we were use `dplyr::lag()` to compare **Day-over-Day (DoD)** margin, we
would be missing `2024-01-02`, `2024-01-04`, and `2024-01-05` which would lead to incorrect answers or trends.

```{r}
#| label: tbl-missing-dates-issues-1
#| tbl-cap: "Incomplete calendar table can lead to wrong conclusions or trends"
#| echo: false

tibble::tibble(
  date=c(" 2024-01-01","2024-01-03","2024-01-06","2024-01-07","2024-01-08","2024-01-09","2024-01-11")
  ,margin=c(1200,1100,1300,900,1200,850,1450)
) |> 
  tinytable::tt(width=.7)
```


To correct this, `fpaR` will automatically complete your calendar for each group for the missing periods to ensure there are no missing periods when calculating trends.

In @tbl-missing-dates-issue-1-fix-no-echo we see a complete calendar set and a new column, "missing_date_indicator" to indicate how many dates were missing.


```{r}
#| label: tbl-missing-dates-issue-1-fix-no-echo
#| tbl-cap: "Original table now complete with missing dates and a missing date indicator"
#| echo: false

tibble::tibble(
  order_date=lubridate::ymd(c("2024-01-01","2024-01-03","2024-01-06","2024-01-07","2024-01-08","2024-01-09","2024-01-11"))
  ,margin=c(1200,1100,1300,900,1200,850,1450)
) |> 
   fpaR::dod(.date = order_date,.value = margin,calendar_type = "standard") |> 
   fpaR:::create_calendar() |> 
   dplyr::arrange(date) |> 
   dplyr::collect() |>
   tinytable::tt(width=.7)

```

### Issue 2: Period imbalances

When comparing two performance periods with a standard calendar, you can often  compare periods with unequal number of days or periods.

For example if you want to compare January sales to February you can get misleading conclusions due to the unequal number of weekends and days in those periods.

> In practice you have two choices:
>
 -  compare periods with similar days (eg. the 28th of February compares should only compare up to the 28th of January) and you omit three days of January sales all together 
>
-  compare have an imbalanced comparison (eg. the 28th of February compares to the 31st of January so that no days are lost).

This package does the second option to  ensure we don't loose any of January's sales but to help flag for imbalance, fpaR will add a column to let you know how many periods (eg. days) are in your comparison period to increase transparency to this dynamic.

To create this example, we will use the `pmtd()` function to calculate the prior month to date cumulative margin in the current month.

```{r}
#| label: issue2-example-echo
#| echo: true
#| eval: false

contoso::sales |>
   fpaR::pmtd(order_date,margin,"standard",lag_n = 1)

```

When we pass the ti object through to `calculate()` and filter the results for February 2022, we would see the below @tbl-issue2-example-no-echo.

On 2022-02-28, we see that is comparing 31 days of the previous period to the 28 days in the current period.



```{r}
#| label: tbl-issue2-example-no-echo
#| echo: false


contoso::sales |> 
   fpaR::pmtd(order_date,margin,"standard",1) |> 
   fpaR::calculate() |> 
    dplyr::filter(
      TRUE
      ,month %in% c(2)
      ,day(date) > 25
      ,year %in% c(2022)
   ) |> 
   dplyr::arrange(date)  |> 
   dplyr::collect() |> 
   tinytable::tt(width=1)
```

Alternatively, if your industries requires non-standard calendars like `5-4-4`, `4-5-4`, or `4-4-5` simply put that as calendar type to see calculations on that basis.


```{r}
#| label: issue3-example-echo
#| echo: true
#| eval: false

contoso::sales |>
   fpaR::pmtd(order_date,margin,calendar_type = "544",lag_n = 1)

```


### Issues 3: larger than memory

If your data isn't already in a database then fpaR will leverage duckdb to convert your data to enable larger than memory calculation. 

This is necessary for time intelligence functions because when you have grouped data, you need to complete calendar for each group combination. For even modest datasets, this can quickly multiple and grow you data to be larger than memory. 

If your data is already in database, then fpaR will use [dbplyr](https://dbplyr.tidyverse.org/) and will convert the functions to SQL to write the queries.

In either scenario, you can use `dplyr::collect()` to execute your SQL query and return a tibble to your local computer. 


```{r}
#| label: db-vs-excel
#| echo: true
#| eval: false
#| warning: false
#| message: false
#| include: true

# quickly load contoso package to a database via the contoso package
db <- contoso::create_contoso_duckdb()

# pass through to the same function mtd()
db$sales |> mtd(order_date,margin,"standard")

# same syntax even though data source is now a tibble

contoso::sales |> mtd(order_date,margin,"standard")
```

